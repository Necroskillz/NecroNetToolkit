<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Reflection" #>
<#Prepare(); #>
// <auto-generated />
// This file was generated by a T4 template.
// Don't change it directly as your change would get overwritten.  Instead, make changes
// to the .tt file (i.e. the T4 template) and save it to regenerate this file.

// Make sure the compiler doesn't complain about missing Xml comments
using NecroNet.Toolkit.EntityFramework;
<# foreach (var ns in Namespaces) { #>
using <#= ns #>;
<# } #>

namespace <#= DefaultNamespace #>
{
<# foreach (ObjectContextInfo contextInfo in ObjectContextInfos) { #>
	public abstract partial class <#= contextInfo.TypeName #>RepositoryBase<TEntity> : EdmRepositoryBase<<#= contextInfo.TypeName #>, TEntity>
		where TEntity : class
	{
		protected override <#= contextInfo.TypeName #> ObjectContext
		{
			get
			{
				return (<#= contextInfo.TypeName #>)UnitOfWork.CurrentContext;
			}
		}
	}
<# foreach (EntitySetInfo entitySetInfo in contextInfo.EntitySets) { #>

	// Entity Set : <#= entitySetInfo.SetName #> | Type Name : <#= entitySetInfo.TypeName #>
	public partial interface I<#= entitySetInfo.TypeName #>Repository : IRepository<<#= entitySetInfo.TypeName #>>
	{
	}
	
	[EntitySetName("<#= entitySetInfo.SetName #>")]
	public partial class <#= entitySetInfo.TypeName #>Repository : <#= contextInfo.TypeName #>RepositoryBase<<#= entitySetInfo.TypeName #>>, I<#= entitySetInfo.TypeName #>Repository
	{
	}
<# } #>
<# } #>

<# foreach (ObjectContextInfo contextInfo in CodeFirstInfos) { #>
	public abstract partial class <#= contextInfo.TypeName #>RepositoryBase<TEntity> : CodeFirstRepositoryBase<<#= contextInfo.TypeName #>, TEntity>
		where TEntity : class
	{
		protected override <#= contextInfo.TypeName #> DbContext
		{
			get
			{
				return (<#= contextInfo.TypeName #>)UnitOfWork.CurrentContext;
			}
		}
	}
<# foreach (EntitySetInfo entitySetInfo in contextInfo.EntitySets) { #>

	// Type Name : <#= entitySetInfo.TypeName #>
	public partial interface I<#= entitySetInfo.TypeName #>Repository : IRepository<<#= entitySetInfo.TypeName #>>
	{
	}
	
	public partial class <#= entitySetInfo.TypeName #>Repository : <#= contextInfo.TypeName #>RepositoryBase<<#= entitySetInfo.TypeName #>>, I<#= entitySetInfo.TypeName #>Repository
	{
	}
<# } #>
<# } #>
}
	
<#+
static DTE Dte;
static List<string> Edmx;
static List<ObjectContextInfo> CodeFirstInfos;
static List<string> Namespaces;
static string DefaultNamespace;
static List<ObjectContextInfo> ObjectContextInfos;
static string CurrentNamespace;

void Prepare()
{
	Namespaces = new List<string>();
	Edmx = new List<string>();
	var serviceProvider = Host as IServiceProvider;
	if (serviceProvider != null) {
		Dte = serviceProvider.GetService(typeof(SDTE)) as DTE;
	}
	
	var project = GetProjectContainingT4File(Dte);
	DefaultNamespace = project.Properties.Item("DefaultNamespace").Value.ToString();
	FindEdmx(project.ProjectItems);
	
	ObjectContextInfos = GetEntityNames();
	CodeFirstInfos = new List<ObjectContextInfo>();
	
	FindDbContext(project.ProjectItems);
}

void FindDbContext(ProjectItems projectItems)
{
    foreach(var item in projectItems.Cast<ProjectItem>())
    {
        if(item.FileCodeModel!=null )
        {
            RecurseFindElements(item.FileCodeModel.CodeElements);
        }
		else
		{
			FindDbContext(item.ProjectItems);
		}
    }
}

private void RecurseFindElements(CodeElements codeElements)
{
	var q = codeElements.Cast<CodeElement>();
	
	foreach (var element in q)
	{
	    if (element is CodeClass)
	    {
	    	var c = (CodeClass)element;
	        //verify element is a project element not an external
	        if (c.InfoLocation==vsCMInfoLocation.vsCMInfoLocationProject && c.IsDerivedFrom["System.Data.Entity.DbContext"])
	    	{
	        	var info = new ObjectContextInfo();
				info.TypeName = c.Name;
				info.EntitySets = FindDbSets(c);
				CodeFirstInfos.Add(info);
				if(CurrentNamespace != null && !Namespaces.Contains(CurrentNamespace)) Namespaces.Add(CurrentNamespace);
	    	}
	    }
	    if (element is CodeNamespace)
	    {
	        var ns=(CodeNamespace)element;
			CurrentNamespace = ns.Name;
	    	RecurseFindElements(ns.Members);
	    }
	}
}

private List<EntitySetInfo> FindDbSets(CodeClass c)
{
	var q = c.Members.Cast<CodeElement>();
	var infos = new List<EntitySetInfo>();
	
	foreach (var element in q)
	{
		if(element is CodeProperty)
		{
			var property = (CodeProperty)element;
			if(property.Type.CodeType.Name == "DbSet");
			{
				var info = new EntitySetInfo();
				var propertyTypeName = property.Type.AsString;
				var start = propertyTypeName.LastIndexOf('.') + 1;
				var len = propertyTypeName.IndexOf('>') - start;
				info.TypeName = propertyTypeName.Substring(start, len);
				infos.Add(info);
			}
		}
	}
	
	return infos;
}

List<ObjectContextInfo> GetEntityNames()
{
	var infos = new List<ObjectContextInfo>();
	XNamespace edmxNs = "http://schemas.microsoft.com/ado/2008/10/edmx";
	XNamespace innerNs = "http://schemas.microsoft.com/ado/2008/09/edm";
	foreach (var edmx in Edmx)
	{
		var info = new ObjectContextInfo();
		var document = XDocument.Load(edmx);
		
		var conceptualModel = document.Descendants(edmxNs + "ConceptualModels").First();
		
		info.TypeName = ((string) conceptualModel.Descendants(innerNs + "EntityContainer").First().Attribute("Name"));
		
		info.EntitySets = (from e in conceptualModel.Descendants(innerNs + "EntitySet")
						   select new EntitySetInfo
									{
										SetName = (string) e.Attribute("Name"),
										TypeName = GetTypeName((string) e.Attribute("EntityType"))
									}).ToList();
									
		infos.Add(info);
	}
	
	return infos;
}

string GetTypeName(string typeName)
{
	return typeName.Substring(typeName.LastIndexOf(".") + 1);
}

void FindEdmx(ProjectItems collection)
{
	if(collection == null || collection.Count == 0)
	{
		return;
	}
	
	foreach (ProjectItem item in collection)
	{
		for (short i = 0; i < item.FileCount; i++)
		{
			string filename = item.FileNames[i];
			if(Path.GetExtension(filename) == ".edmx")
			{
				Edmx.Add(filename);
			}
		}
		
		FindEdmx(item.ProjectItems);
	}
}

Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);

    return projectItem.ContainingProject;
}

class ObjectContextInfo
{
	public string TypeName { get; set; }
	public List<EntitySetInfo> EntitySets { get; set; }
}

class EntitySetInfo
{
	public string SetName { get; set; }
	public string TypeName { get; set; }
}
#>