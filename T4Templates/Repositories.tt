<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Reflection" #>
<#@ include file="Repositories.tt.settings.t4" #>
<# Prepare(); #>
// <auto-generated />
// This file was generated by a T4 template.
// Don't change it directly as your change would get overwritten.  Instead, make changes
// to the .tt file (i.e. the T4 template) and save it to regenerate this file.

using NecroNet.Toolkit.Data;
<# foreach (var ns in Namespaces) { #>
using <#= ns #>;
<# } #>

namespace <#= DefaultNamespace #>
{
<# foreach (ObjectContextInfo contextInfo in ObjectContextInfos) { #>
	public abstract partial class <#= contextInfo.TypeName #>RepositoryBase<TEntity> : Edm<#= IsPOCO ? "POCO" : string.Empty #>RepositoryBase<<#= contextInfo.TypeName #>, TEntity>
		where TEntity : class
	{
<# if (IoCType != IoCFrameworkType.None) { #>
		private readonly IUnitOfWorkManager _unitOfWorkManager;
		
		protected <#= contextInfo.TypeName #>RepositoryBase(IUnitOfWorkManager unitOfWorkManager)
		{
			_unitOfWorkManager = unitOfWorkManager;
		}
		
<# } #>
		protected override <#= contextInfo.TypeName #> ObjectContext
		{
			get
			{
<# if(IoCType == IoCFrameworkType.None) { #>
				return UnitOfWork.GetCurrent<<#= contextInfo.TypeName #>>().Context.AsActual<<#= contextInfo.TypeName #>>();
<# } else { #>
				return _unitOfWorkManager.GetCurrent<<#= contextInfo.TypeName #>>().Context.AsActual<<#= contextInfo.TypeName #>>();
<# } #>
			}
		}
	}
<# foreach (EntitySetInfo entitySetInfo in contextInfo.EntitySets) { #>

	// Entity Set : <#= entitySetInfo.SetName #> | Type Name : <#= entitySetInfo.TypeName #>
	public partial interface I<#= entitySetInfo.TypeName #>Repository : IRepository<<#= entitySetInfo.TypeName #>>
	{
	}
	
	[EntitySetName("<#= entitySetInfo.SetName #>")]
	public partial class <#= entitySetInfo.TypeName #>Repository : <#= contextInfo.TypeName #>RepositoryBase<<#= entitySetInfo.TypeName #>>, I<#= entitySetInfo.TypeName #>Repository
	{
<# if (IoCType != IoCFrameworkType.None) { #>
		public <#= entitySetInfo.TypeName #>Repository(IUnitOfWorkManager unitOfWorkManager) : base(unitOfWorkManager)
		{
		}
<# } #>
	}
<# } #>

<# } #>

<# foreach (ObjectContextInfo contextInfo in CodeFirstInfos) { #>
	public abstract partial class <#= contextInfo.TypeName #>RepositoryBase<TEntity> : CodeFirstRepositoryBase<<#= contextInfo.TypeName #>, TEntity>
		where TEntity : class
	{
<# if (IoCType != IoCFrameworkType.None) { #>
		private readonly IUnitOfWorkManager _unitOfWorkManager;
		
		protected <#= contextInfo.TypeName #>RepositoryBase(IUnitOfWorkManager unitOfWorkManager)
		{
			_unitOfWorkManager = unitOfWorkManager;
		}
		
<# } #>
		protected override <#= contextInfo.TypeName #> DbContext
		{
			get
			{
<# if(IoCType == IoCFrameworkType.None) { #>
				return UnitOfWork.GetCurrent<<#= contextInfo.TypeName #>>().Context.AsActual<<#= contextInfo.TypeName #>>();
<# } else { #>
				return _unitOfWorkManager.GetCurrent<<#= contextInfo.TypeName #>>().Context.AsActual<<#= contextInfo.TypeName #>>();
<# } #>
			}
		}
	}
<# foreach (EntitySetInfo entitySetInfo in contextInfo.EntitySets) { #>

	// Type Name : <#= entitySetInfo.TypeName #>
	public partial interface I<#= entitySetInfo.TypeName #>Repository : IRepository<<#= entitySetInfo.TypeName #>>
	{
	}
	
	public partial class <#= entitySetInfo.TypeName #>Repository : <#= contextInfo.TypeName #>RepositoryBase<<#= entitySetInfo.TypeName #>>, I<#= entitySetInfo.TypeName #>Repository
	{
<# if (IoCType != IoCFrameworkType.None) { #>
		public <#= entitySetInfo.TypeName #>Repository(IUnitOfWorkManager unitOfWorkManager) : base(unitOfWorkManager)
		{
		}
<# } #>
	}
<# } #>

<# } #>
<# if(IoCType != IoCFrameworkType.None) { #>
	// Dependency injection configuration
<# var allObjectContextInfos = CodeFirstInfos.Union(ObjectContextInfos); #>
<# switch (IoCType) {
	case IoCFrameworkType.Ninject: #>
	public class <#= IoCId #>NinjectModule : global::Ninject.Modules.NinjectModule
	{
		public override void Load()
		{
<# foreach (ObjectContextInfo contextInfo in allObjectContextInfos) { #>
			// <#= contextInfo.TypeName #>
<# foreach (EntitySetInfo entitySetInfo in contextInfo.EntitySets) { #>
			Kernel.Bind<I<#= entitySetInfo.TypeName #>Repository>().To<<#= entitySetInfo.TypeName #>Repository>().InSingletonScope();
			Kernel.Bind<IRepository<<#= entitySetInfo.TypeName #>>>().To<<#= entitySetInfo.TypeName #>Repository>().InSingletonScope();
<# } #>
<# } #>
		}
	}
<# break; 
	case IoCFrameworkType.Unity: #>
	public class <#= IoCId #>UnityExtension : global::Microsoft.Practices.Unity.UnityContainerExtension
	{
		protected override void Initialize()
		{
<# foreach (ObjectContextInfo contextInfo in allObjectContextInfos) { #>
			// <#= contextInfo.TypeName #>
<# foreach (EntitySetInfo entitySetInfo in contextInfo.EntitySets) { #>
			Container.RegisterType<I<#= entitySetInfo.TypeName #>Repository, <#= entitySetInfo.TypeName #>Repository>(new ContainerControlledLifetimeManager());
			Container.RegisterType<IRepository<<#= entitySetInfo.TypeName #>>, <#= entitySetInfo.TypeName #>Repository>(new ContainerControlledLifetimeManager());
<# } #>
<# } #>
		}
	}
<# break; 
	case IoCFrameworkType.StructureMap: #>
	public class <#= IoCId #>StructureMapRegistry : global::StructureMap.Configuration.DSL.Registry
	{
		public <#= IoCId #>StructureMapRegistry()
		{
<# foreach (ObjectContextInfo contextInfo in allObjectContextInfos) { #>
			// <#= contextInfo.TypeName #>
<# foreach (EntitySetInfo entitySetInfo in contextInfo.EntitySets) { #>
			ForSingletonOf<I<#= entitySetInfo.TypeName #>Repository>().Use<<#= entitySetInfo.TypeName #>Repository>();
			ForSingletonOf<IRepository<<#= entitySetInfo.TypeName #>>>().Use<<#= entitySetInfo.TypeName #>Repository>();
<# } #>
<# } #>
		}
	}
<# break;
	case IoCFrameworkType.Windsor: #>
	public class <#= IoCId #>WindsorInstaller : global::Castle.MicroKernel.Registration.IWindsorInstaller
	{
		public void Install(global::Castle.Windsor.IWindsorContainer container, global::Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore store)
		{
			container.Register(global::Castle.MicroKernel.Registration.Classes.FromThisAssembly().BasedOn(typeof (IRepository<>)).WithService.AllInterfaces().LifestyleSingleton());
		}
	}
<# break; #>
<# } #>
<# } #>
}

<#+
enum IoCFrameworkType
{
	None,
	Ninject,
	Unity,
	StructureMap,
	Windsor
}

static DTE Dte;
static List<string> Edmx;
static List<ObjectContextInfo> CodeFirstInfos;
static List<string> Namespaces;
static string DefaultNamespace;
static List<ObjectContextInfo> ObjectContextInfos;
static string CurrentNamespace;
static IoCFrameworkType IoCType;
static string IoCId;

void Prepare()
{
	Namespaces = new List<string>();
	Edmx = new List<string>();
	var serviceProvider = Host as IServiceProvider;
	if (serviceProvider != null) {
		Dte = serviceProvider.GetService(typeof(SDTE)) as DTE;
	}
	
	var project = GetProjectContainingT4File(Dte);
	DefaultNamespace = project.Properties.Item("DefaultNamespace").Value.ToString();
	
	if(!OmitEdmx)
	{
		FindEdmx(project.ProjectItems);
	}
	
	ObjectContextInfos = GetEntityNames();
	CodeFirstInfos = new List<ObjectContextInfo>();
	
	FindDbContext(project.ProjectItems);
	
	var ioc = IoC.Split('|');
	IoCType = (IoCFrameworkType)System.Enum.Parse(typeof(IoCFrameworkType), ioc[0], true);
	IoCId = ioc[1];
}

void FindDbContext(ProjectItems projectItems)
{
    foreach(var item in projectItems.Cast<ProjectItem>())
    {
        if(item.FileCodeModel!=null )
        {
            RecurseFindElements(item.FileCodeModel.CodeElements);
        }
		else
		{
			FindDbContext(item.ProjectItems);
		}
    }
}

private void RecurseFindElements(CodeElements codeElements)
{
	var q = codeElements.Cast<CodeElement>();
	
	foreach (var element in q)
	{
	    if (element is CodeClass)
	    {
	    	var c = (CodeClass)element;
	        //verify element is a project element not an external
	        if (c.InfoLocation==vsCMInfoLocation.vsCMInfoLocationProject && c.IsDerivedFrom["System.Data.Entity.DbContext"])
	    	{
	        	var info = new ObjectContextInfo();
				info.TypeName = c.Name;
				info.EntitySets = FindDbSets(c);
				
				if(info.EntitySets.Count > 0)
				{
					CodeFirstInfos.Add(info);
				}
				
				if(CurrentNamespace != null && !Namespaces.Contains(CurrentNamespace)) Namespaces.Add(CurrentNamespace);
	    	}
	    }
	    if (element is CodeNamespace)
	    {
	        var ns=(CodeNamespace)element;
			CurrentNamespace = ns.Name;
	    	RecurseFindElements(ns.Members);
	    }
	}
}

private List<EntitySetInfo> FindDbSets(CodeClass c)
{
	var q = c.Members.Cast<CodeElement>();
	var infos = new List<EntitySetInfo>();
	
	foreach (var element in q)
	{
		if(element is CodeProperty)
		{
			var property = (CodeProperty)element;
			if(property.Type.CodeType.Name == "DbSet")
			{
				var info = new EntitySetInfo();
				var propertyTypeName = property.Type.AsString;
				var start = propertyTypeName.LastIndexOf('.') + 1;
				var len = propertyTypeName.IndexOf('>') - start;
				info.TypeName = propertyTypeName.Substring(start, len);
				infos.Add(info);
			}
		}
	}
	
	return infos;
}

List<ObjectContextInfo> GetEntityNames()
{
	var infos = new List<ObjectContextInfo>();
	XNamespace edmxNs = "http://schemas.microsoft.com/ado/2008/10/edmx";
	XNamespace innerNs = "http://schemas.microsoft.com/ado/2008/09/edm";
	foreach (var edmx in Edmx)
	{
		var info = new ObjectContextInfo();
		var document = XDocument.Load(edmx);
		
		var conceptualModel = document.Descendants(edmxNs + "ConceptualModels").First();
		
		info.TypeName = ((string) conceptualModel.Descendants(innerNs + "EntityContainer").First().Attribute("Name"));
		
		info.EntitySets = (from e in conceptualModel.Descendants(innerNs + "EntitySet")
						   select new EntitySetInfo
									{
										SetName = (string) e.Attribute("Name"),
										TypeName = GetTypeName((string) e.Attribute("EntityType"))
									}).ToList();
									
		infos.Add(info);
	}
	
	return infos;
}

string GetTypeName(string typeName)
{
	return typeName.Substring(typeName.LastIndexOf(".") + 1);
}

void FindEdmx(ProjectItems collection)
{
	if(collection == null || collection.Count == 0)
	{
		return;
	}
	
	foreach (ProjectItem item in collection)
	{
		for (short i = 0; i < item.FileCount; i++)
		{
			string filename = item.FileNames[i];
			if(Path.GetExtension(filename) == ".edmx")
			{
				Edmx.Add(filename);
			}
		}
		
		FindEdmx(item.ProjectItems);
	}
}

Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);

    return projectItem.ContainingProject;
}

class ObjectContextInfo
{
	public string TypeName { get; set; }
	public List<EntitySetInfo> EntitySets { get; set; }
}

class EntitySetInfo
{
	public string SetName { get; set; }
	public string TypeName { get; set; }
}
#>